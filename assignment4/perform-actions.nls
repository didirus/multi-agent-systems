; This file handles all actions, after desire and intention
; has been determined. Contains no further comments as the
; code is self-explanatory.

to perform-actions
  if at-stop? [
    if intention = "drop_off" [drop-off-passengers]
    if intention = "pick_up" [pick-up-passengers]]
  
  if intention = "drive"[
    if next_stop = -1 [set next_stop next-stop?]
    travel-to next_stop]
end

to drop-off-passengers
  foreach bus_passengers [ let passenger ?
    if wants-to-leave passenger [
      drop-off passenger
      if debug_traffic [mention "Dropped off" passenger]]]
end

to pick-up-passengers
  foreach get-passengers-at-stop current_stop [ let passenger ?
    if wants-to-enter passenger and not overloaded? [
      pick-up passenger
      if debug_traffic [mention "Picked up" passenger]]
]
end

to pick-up [passenger] pick-up-passenger id-of passenger end
to drop-off [passenger] drop-off-passenger id-of passenger end

to-report next-stop?
  set track_index (track_index + 1) mod (length track)
  report item track_index track
end

to mention [message passenger]
  show (word message " passenger "id-of passenger " (dest=" destination-of passenger ") at stop " current_stop) 
end

to set-track [source target]
  ; Called when initialising a bus
  ; Checks whether the bus is already in its district
  ; If in district: set to default district route
  ; Else, find shortest path to district
  
  ; property used to track available buses in other districts when buying.
  ; based on it's own district, therefore better to set it here then
  ; in init-buses
  if debug_traffic [ debug (word "I am setting my track, therefore also resetting my overloaded/other_district_blockers information.")] 
  reset-overloaded/other_district_blockers
  
  ifelse member? source target
  
  [ update-track
    set in_district true] 
  [
    ; Determine the shortest path to the district
    ; by evaluating every busstop in the district 
    ; with Dijkstra's algorithm
    
    let shortest_stop 99 
    let min_cost 10000000
    foreach target [
      let busstop ?
      let output table:get dijkstra (list source busstop)
      let cost item 1 output
      if cost < min_cost [
        set shortest_stop busstop
        set min_cost cost]]
    let route first table:get dijkstra (list source shortest_stop)
    set track route ]
end

to update-track
  if district != -1 [
    if track = 0 or current_stop = last track [  
      set track item district districts ; pick default district route      
      if not in_district [set track_index position current_stop track ]]]
end