; This file contains all kinds of auxiliary procedures.

to-report all-buses? ; Returns list with the IDs of all buses, except my own.
  let ids []
  
  ; for all buses, get bus ids
  ask buses [ set ids lput bus_id ids ]
  
  ; remove own index from ids
  set ids remove bus_id ids
  
  ; return id list
  report ids
end

to-report newest-bus? ; Returns the ID of the newest bus.
  report max fput bus_id all-buses?
end
 
to-report waiting-passengers? ; Returns whether there are waiting passengers.
  report any? bus_stops with [length passengers_waiting > 0]
end

to-report overloaded? ; Returns whether this bus is full.
  report capacity? = length bus_passengers
end

to-report capacity? ; Returns my capacity according to my bus type.
  if bus_type = 1 [report bus_type1_capacity]
  if bus_type = 2 [report bus_type2_capacity]
  if bus_type = 3 [report bus_type3_capacity]
end

to-report at-junction? ; Returns whether I'm currently at a junction.
  let boolean false
  
  ; for each district list/set
  foreach districts [
    let pos position ? districts
    
    ; for all other districts
    if pos != district [
      
      ; if I'm at any junction, return true
      if member? current_stop table:get junctions (list district pos) [
        set boolean true ]]]
  
  ; return outcome
  report boolean
end

to-report at-stop? ; Returns whether I'm at a stop. 
  report current_stop != -1
end

to-report assigned-to-district? ; Returns whether I'm currently assigned to a district.
  report district != -1
end

to-report home? ; Returns whether I'm currently in my assigned district.
  report true
end

to-report in-my-district [destination] ; Returns whether `destination` is stop in my district.
  report member? destination item district districts
end

to-report intersect [a b] ; Returns intersection of lists `a` and `b`.
  report (filter [ member? ? b ] a)
end

to-report any [collection predicate] ; Returns whether `predicate` is true for each element of `collection`.
  report not empty? collection and reduce [?1 or (runresult predicate ?2)] (fput false collection)
end
  
to-report index-in-range [ number ]
  let range []
  let i 0
  while [i < number] [
     set range lput i range
     set i i + 1]
  report range
end

to-report enumerate [ collection ]
  report index-in-range length collection
end

to-report in-district?
  report member? current_stop stops?
end

to-report stops?
   report item district districts
end

to-report stops-of [ some-district ]
  report item some-district districts
end

to-report determine-junctions? ; Returns table mapping pair of districts to their overlapping stops
  let junction_table table:make
  foreach enumerate districts [ let district_a ?
    foreach enumerate districts [ let district_b ?
      if district_a != district_b [
        table:put junction_table (list district_a district_b)
         reduce intersect (list stops-of district_a stops-of district_b) ]]]
  
  report junction_table
end

to debug [text]
  let preamble ""
  
  if debug_show_ticks [ set preamble (word preamble "[" ticks "]")]
  
  if debug_show_districts [
    ifelse assigned-to-district? [ 
      set preamble (word preamble "[D" district "]")]
    [
      set preamble (word preamble "[--]")]]
  
  show (word preamble " " text)
end

to reset-overloaded/other_district_blockers
  set overloaded/other_district_blockers table:make
  foreach districts [
    let i position ? districts
    if i != district [
      table:put overloaded/other_district_blockers i []
    ]
  ] 
end

to handle-timers
  
  ; handle buy timer
  if overloaded/timer > 0 [
    ; Decrease waiting time to buy new buses.
    set overloaded/timer overloaded/timer - 1]
  
  ; handle reallocation timer
  if overloaded/reallocation_timer > 0 [
    set overloaded/reallocation_timer (overloaded/reallocation_timer - 1)]
end

to mark
  print marker
end

to mark-personal
  debug marker
end