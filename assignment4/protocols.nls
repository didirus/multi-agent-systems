; This file contains all protocols. Given a protocol, a bus can 'lead'
; or 'follow'. 'Follow' means it responds according to the protocol to
; an incoming message. 'Lead' means it takes action according to the
; protocol, not being prompted by an incoming message. Accordingly,
; for each protocol, for instance 'overloaded', there is a lead
; procedure `lead-overloaded` and a follow function `follow-overloaded`.


to lead-protocols ; Loops through the lead procedures of all protocols.
  lead-overloaded
end

to clear-temporary-memory
  reset-overloaded/other_district_blockers
  set overloaded/other_buyers []
  set overloaded/oldest_buyer 9999
  set overloaded/oldest_requester 9999
end

to lead-overloaded
  if overloaded/timer > 0 [
    ; Decrease waiting time to buy new buses.
    set overloaded/timer overloaded/timer - 1]
  
  if overloaded/state = overloaded:UNINITIATED [
    if overloaded? and not (overloaded/timer > 0) [
      
      ; I'm overloaded and waited long enough, so initiate protocol!
      
      broadcast "overloaded" overloaded.want_to_buy district  ; Broadcast 'want to buy' to all other buses.
      set overloaded/state overloaded:AWAITING_RESPONSE]      ; Change internal protocol state accordingly.
    stop]
  
  if overloaded/state = overloaded:AWAITING_RESPONSE [
    
    ; In the previous tick I decided to buy a bus. This tick I
    ; am awaiting responses of other buses. I will switch my state to
    ; indicate that I will try and buy a bus next tick 
    
    set overloaded/state overloaded:ABOUT_TO_BUY
    stop]
  
  if overloaded/state = overloaded:COLLIDED [
    
    ; During this tick I've received messages of other buses, with the same district as mine,
    ; that (in the previous tick) decided to buy a bus. I can now decide which of us will buy
    ; a bus, based on our age: the oldest bus wil try to buy a bus next tick (indicated by my new
    ; state). Other buses will now stop their protocol.
    
    ifelse bus_id < overloaded/oldest_requester [
      set overloaded/state overloaded:ABOUT_TO_BUY
      if debug_messages [ debug (word "I am the oldest bus. Will try to buy next tick.")] ]
    [ 
      if debug_messages [ debug (word "I am not the oldest bus. Quitting protocol.")]
      end-overloaded ]
    stop]
  
  if overloaded/state = overloaded:ABOUT_TO_BUY [
    
     ; Apparently, no-one in my district still has capacity. So buy!
     ; I will check my stored messages if other districts can help out, if so I 
     ; will call someone from another district to come and help me. Else: buy a new bus
     
     ; initiate tracker variable
     ; keeps track of [#district_with_most_available_buses #amount_of_available_buses_there]
     let most_quiet_district [999 999]
          
     ; for all other districts
     foreach districts [
       let i position ? districts
      
       ; if it is not my own district
       if i != district [
         let helpers table:get overloaded/other_district_blockers i
         
         ; if threshold of 2 is reached and a new record is seen, store in tracker variable
         if length helpers >= 2 and length helpers < item 1 most_quiet_district [
           set most_quiet_district (list i length helpers) ]]]
     
     ; check for the most quiet district. If another district is quiet enough, command a bus
     ; to come to my district.
     ifelse item 0 most_quiet_district != 999 [
       if debug_messages [ debug (word "District " item 0 most_quiet_district " can help me out! I will assign a random bus of that district to mine.")]
       print "--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------"
       let helper one-of table:get overloaded/other_district_blockers item 0 most_quiet_district
       send helper "overloaded" overloaded.come_to_district district
       end-overloaded]
     
     ; else: no other district is quiet enough to exchange buses, now decide to buy a bus
     [ if debug_messages [ debug (word "No answers from my district. No other districts have enough capacity.")]
     buy]

     stop]
  
  if overloaded/state = OVERLOADED:INSTRUCTING and overloaded/newest_bus != newest-bus? [
    ifelse newest-bus? - overloaded/newest_bus = 1 [
      
      ; I just ordered a new bus, and I now see it has been
      ; delivered. So I need to instruct it to drive in my district.
      
      send newest-bus? "overloaded" overloaded.come_to_district district
      end-overloaded]
    [
      ; I just bought a new bus, but apparently, others did as well. We (the buyers) now
      ; need to identify each other, in order to decide who of us will instruct the new
      ; buses to which districts they belong.
      broadcast "overloaded" overloaded.we_both_bought district
      set overloaded/state overloaded:BOUGHT_SIMULTANEOUSLY]  
    stop]
  
  if overloaded/state = overloaded:RESOLVING_SIMULTANEOUS_BUY [
    if bus_id < overloaded/oldest_buyer [
      
      ; Apparently I was the oldest of the simultaneous buyers. Now that I know everyone's district,
      ; I will instruct the new buses where to go.

      ; Decide for the first bus to go to my district.
      send (overloaded/newest_bus + 1) "overloaded" overloaded.come_to_district district
      
      ; Distribute other buses accordingly.
      let i 0
      while [ i < length overloaded/other_buyers ] [
        send (overloaded/newest_bus + 2 + i) "overloaded" overloaded.come_to_district item i overloaded/other_buyers
        set i (i + 1)]]
    
    ; for all buses involved, end the protocol
    end-overloaded
    stop]
end

to follow-overloaded [sender body details] ; This function is called after incoming 'overloaded' messages.
  
  if body = overloaded.want_to_buy and details = district and overloaded/state = overloaded:UNINITIATED [
    
    ; A fellow district member wants to buy, but I still
    ; have capacity. So I block his buy.
    
    if not overloaded? [send sender "overloaded" overloaded.do_not_buy district]
    stop]
  
  if body = overloaded.want_to_buy and details != district and overloaded/state = overloaded:UNINITIATED [
    
    ; Someone from another district wants to buy, but I still
    ; have capacity. Ill inform him if I still have capacity.
    
    if not overloaded? [send sender "overloaded" overloaded.do_not_buy district]
    stop]
  
  
  if body = overloaded.want_to_buy and details = district and overloaded/state = overloaded:AWAITING_RESPONSE [
    
    ; A fellow district member also wants to buy. Collision!
    ; We keep track of the oldest bus, which is the one responsible for buying a bus
    
    if debug_messages [ debug (word "I collided with bus " sender " during buying. We will resolve this conflict.")] 
    
    if sender < overloaded/oldest_requester [ set overloaded/oldest_requester sender ]
    set overloaded/state overloaded:COLLIDED
    stop]
  
  if body = overloaded.do_not_buy [

    ; A fellow district member still has capacity, so I don't have to buy.
    ifelse details = district [
      if debug_messages [ debug (word "Bus " sender " from D" details " told me not to buy a bus.)] 
      end-overloaded]
    ; else: Someone from another district wants to help out
    [ 
      if debug_messages [ debug (word "Bus " sender " from D" details " said he might be available to help.")] 
      let other_district_blockers table:get overloaded/other_district_blockers details
      set other_district_blockers lput sender other_district_blockers
      table:put overloaded/other_district_blockers details other_district_blockers]
 
    stop]
  
  if body = overloaded.come_to_district [
    
    ; I have just been bought, and this message contains the district I should be driving.
    
    set district details
    set-track 3 item district districts
    set next_stop -1
    set desire "routine"
    if debug_messages [ debug (word "I have been assigned to D" district ".")]
    set overloaded/state overloaded:UNINITIATED
    stop]

  if body = overloaded.we_both_bought and overloaded/state = overloaded:BOUGHT_SIMULTANEOUSLY [
    
    ; I detect the others which also simultaneously bought a bus and store their bus IDs
    ; This tick, I will decide which of us will buy the bus
    
    if debug_messages [ debug (word "I bought at the same time as " sender ". We will resolve this conflict.")] 
    
    if sender < overloaded/oldest_buyer [ set overloaded/oldest_buyer sender ]
    set overloaded/other_buyers lput details overloaded/other_buyers
    set overloaded/state overloaded:RESOLVING_SIMULTANEOUS_BUY
    
    stop]
end

to buy
  ifelse overloaded? [
    add-bus 2
    set overloaded/newest_bus newest-bus?
    set overloaded/state overloaded:INSTRUCTING
    if debug_messages [ debug (word "I bought a bus.")]]
  [
    if debug_messages [ debug (word "I was about to buy, but had capacity again.")]
    end-overloaded]
end

to end-overloaded
  if debug_messages [ debug (word "I am ending the protocol from state " overloaded/state ".")]
  set overloaded/timer overloaded/timeout
  set overloaded/state overloaded:UNINITIATED
  clear-temporary-memory
end