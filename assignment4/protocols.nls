; This file contains all protocols. Given a protocol, a bus can 'lead'
; or 'follow'. 'Follow' means it responds according to the protocol to
; an incoming message. 'Lead' means it takes action according to the
; protocol, not being prompted by an incoming message. Accordingly,
; for each protocol, for instance 'overloaded', there is a lead
; procedure `lead-overloaded` and a follow function `follow-overloaded`.


to lead-protocols ; Loops through the lead procedures of all protocols.
  lead-overloaded
end

to finish-protocols ; Loops through the finish procedures of all protocols.
  finish-overloaded
  clear-temporary-memory
end

to clear-temporary-memory
  set overloaded/other_buyers []
end

to lead-overloaded
  if overloaded/timer > 0 [
    ; Decrease waiting time to buy new buses.
    set overloaded/timer overloaded/timer - 1]
  
  if overloaded/state = overloaded:UNINITIATED [
    if overloaded? and not (overloaded/timer > 0) [
      
      ; I'm overloaded and waited long enough, so initiate protocol!
      
      broadcast "overloaded" overloaded.want_to_buy district  ; Broadcast 'want to buy' to all other buses.
      set overloaded/state overloaded:ABOUT_TO_BUY]        ; Change internal protocol state accordingly.
    stop]
  
  if overloaded/state = overloaded:ABOUT_TO_BUY [
    
     ; Apparently, no-one in my district still has capacity. So buy!
     
     if debug_messages [ show (word "No one on district " district " answered my call." ticks)]
     buy
     stop]
  
  if overloaded/state = OVERLOADED:INSTRUCTING and overloaded/newest_bus != newest-bus? [
    ifelse newest-bus? - overloaded/newest_bus = 1 [
      
      ; I just ordered a new bus, and I now see it has been
      ; delivered. So I need to instruct it to drive in my district.
      
      send newest-bus? "overloaded" overloaded.come_to_my_district district
      end-overloaded]
    [
      ; I just bought a new bus, but apparently, others did as well. We (the buyers) now
      ; need to identify each other, in order to decide who of us will instruct the new
      ; buses to which districts they belong.
      broadcast "overloaded" overloaded.we_both_bought district
      set overloaded/state overloaded:BOUGHT_SIMULTANEOUSLY]  
    stop]
end

to follow-overloaded [sender body details] ; This function is called after incoming 'overloaded' messages.
  
  if body = overloaded.want_to_buy and details = district and overloaded/state = overloaded:UNINITIATED [
    
    ; A fellow district member wants to buy, but I still
    ; have capacity. So I block his buy.
    
    if not overloaded? [send sender "overloaded" overloaded.do_not_buy "void"]
    stop]
  
  if body = overloaded.want_to_buy and details = district and overloaded/state = overloaded:ABOUT_TO_BUY [
    
    ; A fellow district member also wants to buy. Collision!
    ; We both throw a dice; highest number wins and buys.
    
    set overloaded/dice random 500
    send sender "overloaded" overloaded.we_collided overloaded/dice ; Store the number I got.
    set overloaded/state overloaded:COLLIDED
    stop]
  
  if body = overloaded.we_collided [
    
    ; I received the dice throw of the other bus. Let's see who won!
    
    ifelse overloaded/dice >= details [
      if debug_messages [ show (word "Won! I threw " overloaded/dice ", bus " sender " threw " details ".")]
      buy]
    [
      if debug_messages [ show (word "Lost :(. I threw " overloaded/dice ", bus " sender " threw " details ".")]
      end-overloaded]
    stop]
  
  if body = overloaded.do_not_buy [
    
    ; A fellow district member still has capacity, so I don't have to buy.
    
    if debug_messages [ show (word "Bus " sender " told me not to buy a bus for district " district "." ticks)] 
    end-overloaded
    stop]
  
  if body = overloaded.come_to_my_district [
    
    ; I have just been bought, and this message contains the district I should be driving.
    
    set district details
    set-track 3 item district districts
    set next_stop item track_index track 
    set desire "routine"
    if debug_messages [ show (word "I have been instructed to drive in district " district "." ticks)]
    set overloaded/state overloaded:UNINITIATED
    stop]

  if body = overloaded.we_both_bought and overloaded/state = overloaded:BOUGHT_SIMULTANEOUSLY [
    if sender < overloaded/oldest_buyer [ set overloaded/oldest_buyer sender ]
    set overloaded/other_buyers lput details overloaded/other_buyers
    stop]
end

to finish-overloaded
  if overloaded/state = overloaded:BOUGHT_SIMULTANEOUSLY [
    if bus_id < overloaded/oldest_buyer [
      ; Apparently I was the oldest of the simultaneous buyers. Now that I know everyone's district,
      ; I will instruct the new buses where to go.
      
      send (overloaded/newest_bus + 1) "overloaded" overloaded.come_to_my_district district
    
      let i 0
    
      while [ i < length overloaded/other_buyers ] [
        send (overloaded/newest_bus + 2 + i) "overloaded" overloaded.come_to_my_district item i overloaded/other_buyers]]
    end-overloaded]
end

to buy
  ifelse overloaded? [
    add-bus 2
    set overloaded/newest_bus newest-bus?
    set overloaded/state overloaded:INSTRUCTING
    if debug_messages [ show (word "I bought a bus for district " district "." ticks)]]
  [
    if debug_messages [ show (word "I was about to buy a bus for district " district ", but had capacity again.")]
    end-overloaded]
end

to end-overloaded
  set overloaded/timer overloaded/timeout
  set overloaded/state overloaded:UNINITIATED
end