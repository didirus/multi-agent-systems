; This file contains all kinds of auxiliary procedures.

to-report all-buses? ; Returns list with the IDs of all buses, except my own.
  let ids []
  
  ; for all buses, get bus ids
  ask buses [ set ids lput bus_id ids ]
  
  ; remove own index from ids
  set ids remove bus_id ids
  
  ; return id list
  report ids
end

to-report newest-bus? ; Returns the ID of the newest bus.
  report max fput bus_id all-buses?
end
 
to-report waiting-passengers? ; Returns whether there are waiting passengers.
  report any? bus_stops with [length passengers_waiting > 0]
end

to-report overloaded? ; Returns whether this bus is full.
  report capacity? = length bus_passengers
end

to-report capacity? ; Returns my capacity according to my bus type.
  if bus_type = 1 [report bus_type1_capacity]
  if bus_type = 2 [report bus_type2_capacity]
  if bus_type = 3 [report bus_type3_capacity]
end

to-report at-junction? ; Returns whether I'm currently at a junction.
  let boolean false
  
  ; for each district list/set
  foreach districts [
    let pos position ? districts
    
    ; for all other districts
    if pos != district [
      
      ; if I'm at any junction, return true
      if member? current_stop table:get junctions (list district pos) [
        set boolean true ]]]
  
  ; return outcome
  report boolean
end

to-report at-stop? ; Returns whether I'm at a stop. 
  report current_stop != -1
end

to-report in-my-district [destination] ; Returns whether `destination` is stop in my district.
  report member? destination item district districts
end

to-report intersect [a b] ; Returns intersection of lists `a` and `b`.
  report (filter [ member? ? b ] a)
end

to-report any [collection predicate] ; Returns whether `predicate` is true for each element of `collection`.
  report not empty? collection and reduce [?1 or (runresult predicate ?2)] (fput false collection)
end

to-report in-district?
  report member? current_stop item district districts
end

to set-junctions
  
  ; create hash table
  let juncts table:make 
  
  ; for all district combinations
  foreach districts [
    let i ?
    let index_i position i districts
    foreach districts [
      let j ?
      let index_j position j districts
      
      ; store intersection of the to district lists 
      if index_i != index_j [
        table:put juncts (list index_i index_j) reduce intersect (list i j) ]]]
  
  ; store hash table in property
  set junctions juncts
end

to debug [text]
  ifelse debug_ticks[
    show (word "[" ticks "] " text)]
  [
    show text]
end